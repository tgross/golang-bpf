# Experiment 03: Minimal Example (uretprobes)


A uretprobe for returning simple integers seems to work fine:

```
uprobe:./bin/minimal:"main.add"
{
    printf("adding %d and %d\n", sarg0, sarg1);
}

uretprobe:./bin/minimal:"main.add"
{
    printf("returned %d\n", retval);
}
```

The `retval` has the integer returned.

```
$ sudo ./scripts/03-minimal-01-uretprobe.bt
Attaching 3 probes...
Waiting... Hit Ctrl-C to end.
adding 42 and 13
returned 55
adding 1 and 3
returned 4
adding 7 and 11
returned 18
```

What about returning multiple values?


```
uretprobe:./bin/minimal:"main.swap"
{
    printf("returned \"%s\"\n", str(retval));
}
```

```
$ sudo ./scripts/03-minimal-02-uretprobe-multiple.bt
Attaching 3 probes...
Waiting... Hit Ctrl-C to end.
swapping "hello" and "world"
returned ""
^C
```

Well what could we really have expected there?  We can only return 1
value, which in AMD64 will be in `rax` if it's an integer, or on the
stack if it's a "large value" like a struct. It's probably a safe bet
that golang treats multiple returns this way, too.

On top of that, there's are several known issues ([bpftrace
#970](https://github.com/iovisor/bpftrace/issues/970) [bcc
#1320](https://github.com/iovisor/bcc/issues/1320)) with golang and
uretprobes. This boils down to golang's concurrency model. Instead of
using a thread for every goroutine, golang multiplexes goroutines
across multiple threads ("M:N scheduling"). So instead of each thread
having a default 2MB stack, each goroutine has a tiny 2KB stack that's
managed by the golang runtime instead of the operating system. When
the program needs to grow the stack for a goroutine and there's not
enough room, the runtime copies the entire goroutine's stack to
another place in memory where it has enough room to expand. But that
means that the return locations are no longer valid, and so a
uretprobe that fires may be reading into memory that's been reused for
something else!

The advice from BPF developer folks have been to trace the function
from the uprobe, but with offsets onto each return. I haven't actually
seen how to do that written down anywhere, so I wanted to explore that
here.

Let's disassemble `main.swap`:

```
(gdb) b main.swap
(gdb) run
(gdb) disas
Dump of assembler code for function main.swap:
=> 0x0000000000494e80 <+0>:     mov    rax,QWORD PTR [rsp+0x18]
   0x0000000000494e85 <+5>:     mov    QWORD PTR [rsp+0x28],rax
   0x0000000000494e8a <+10>:    mov    rax,QWORD PTR [rsp+0x20]
   0x0000000000494e8f <+15>:    mov    QWORD PTR [rsp+0x30],rax
   0x0000000000494e94 <+20>:    mov    rax,QWORD PTR [rsp+0x8]
   0x0000000000494e99 <+25>:    mov    QWORD PTR [rsp+0x38],rax
   0x0000000000494e9e <+30>:    mov    rax,QWORD PTR [rsp+0x10]
   0x0000000000494ea3 <+35>:    mov    QWORD PTR [rsp+0x40],rax
   0x0000000000494ea8 <+40>:    ret
End of assembler dump.
```

I'm doing this in `gdb` because I want to explore a bit, but you can
also dump the assembly with `objdump`.

<details><summary>objdump example</summary>

```
$ objdump --disassemble=main.swap -S ./bin/minimal

./bin/minimal:     file format elf64-x86-64


Disassembly of section .text:

0000000000494e80 <main.swap>:
        return x + y
}

// function that returns strings
func swap(x, y string) (string, string) {
        return y, x
  494e80:       48 8b 44 24 18          mov    0x18(%rsp),%rax
  494e85:       48 89 44 24 28          mov    %rax,0x28(%rsp)
  494e8a:       48 8b 44 24 20          mov    0x20(%rsp),%rax
  494e8f:       48 89 44 24 30          mov    %rax,0x30(%rsp)
  494e94:       48 8b 44 24 08          mov    0x8(%rsp),%rax
  494e99:       48 89 44 24 38          mov    %rax,0x38(%rsp)
  494e9e:       48 8b 44 24 10          mov    0x10(%rsp),%rax
  494ea3:       48 89 44 24 40          mov    %rax,0x40(%rsp)
  494ea8:       c3                      retq
```

</details>

We're interested in what's happening when we get to the end of the
function, so let's single-step through until we get to the `ret`:

```
# we hit "si" to single-step through each instruction until we get to the return...
(gdb) si
0x0000000000494ea8 in main.swap (x=..., y=..., ~r2=..., ~r3=...) at <autogenerated>:1
1       in <autogenerated>
   0x0000000000494e85 <main.swap+5>:    48 89 44 24 28  mov    QWORD PTR [rsp+0x28],rax
   0x0000000000494e8a <main.swap+10>:   48 8b 44 24 20  mov    rax,QWORD PTR [rsp+0x20]
   0x0000000000494e8f <main.swap+15>:   48 89 44 24 30  mov    QWORD PTR [rsp+0x30],rax
   0x0000000000494e94 <main.swap+20>:   48 8b 44 24 08  mov    rax,QWORD PTR [rsp+0x8]
   0x0000000000494e99 <main.swap+25>:   48 89 44 24 38  mov    QWORD PTR [rsp+0x38],rax
   0x0000000000494e9e <main.swap+30>:   48 8b 44 24 10  mov    rax,QWORD PTR [rsp+0x10]
   0x0000000000494ea3 <main.swap+35>:   48 89 44 24 40  mov    QWORD PTR [rsp+0x40],rax
=> 0x0000000000494ea8 <main.swap+40>:   c3      ret
   0x0000000000494ea9:  cc      int3
   0x0000000000494eaa:  cc      int3
   0x0000000000494eab:  cc      int3
   0x0000000000494eac:  cc      int3
   0x0000000000494ead:  cc      int3
   0x0000000000494eae:  cc      int3
   0x0000000000494eaf:  cc      int3
```

At this point, we can see we've moved our outputs into pointers offset
from the stack pointer, that point to our strings. These are on the
stack so it's last-in-first-out, which is admittedly a little extra
confusing here because the function's purpose is to swap the
strings. The last instruction at `main.swap+35` was to move `rax` into
`rsp+0x40`, which is our integer of the length:

```
(gdb) x/d $rsp+0x40
0xc000090ea0:   5
```

And the previous instruction moving stuff out of `rax` (at
`main.swap+25`) was into `rsp+0x38`. That'll be a pointer to the start
of our string:

```
(gdb) x/a $rsp+0x38
0xc000090e98:   0x4c4319
(gdb) x/s 0x4c4319
0x4c4319:       "helloint16int32int64panicscav sleepslicesse41sse42ssse3uint8worldwrite Value addr= base  code= ctxt: curg= goid  jobs= list= m->p= next= p->m= prev= span= varp=% util(...)\n, i = , not 390625<-chanArab"...
```

So when we write our fake uretprobe, we'll need to follow these
pointers. If you're like me and basically never have to do pointer
arithmitic in your day job, this can be a little tricky. Here's the
working version:

```
uprobe:./bin/minimal:"main.swap"+40
{
    printf("results: \"%s\" and \"%s\"\n",
        str(*(reg("sp")+0x28), *(reg("sp")+0x30)),
        str(*(reg("sp")+0x38), *(reg("sp")+0x40))
        )
}
```

```
$ sudo ./scripts/03-minimal-02-uretprobe-multiple.bt
Attaching 3 probes...
Waiting... Hit Ctrl-C to end.
swapping "hello" and "world"
results: "world" and "hello"
```

Note that we're adding to the `rsp` address (which walks up the stack)
and then dereferencing the pointer we find at that address. We don't
want to dereference the `rsp` and then walk up from there.

The `03-minimal-03-pointer-chasing.bt` script shows an example of how not to do it:

```
$ sudo ./scripts/03-minimal-03-pointer-chasing.bt
Attaching 2 probes...
Waiting... Hit Ctrl-C to end.
getting the right address...
        reg("sp"):                 64e60  <- rsp address
        reg("sp")+0x28:            64e88  <- rsp address + 28
        *(reg("sp")+0x28):         4c4355  <- dereferenced pointer
        str(*(reg("sp")+0x28), 5): world  <- result

getting the wrong address...
        reg("sp"):                 64e60  <- rsp address
        *reg("sp"):                4950ba  <- dereferenced pointer
        *reg("sp")+0x28:           4950e2  <- dereferenced pointer + 28
        str(*reg("sp")+0x28)):     wBHD$H$  <- total garbage!
^C
```

In the next section, we'll dig into working with objects more complex
than strings.


### References

- [Intel Introduction to x64
  Assembly](https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf)
- [Assembly on Ubuntu](http://www.egr.unlv.edu/~ed/assembly64.pdf)
- [System_V_AMD64_ABI](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI)
- [bpftrace: golang function
  latency](https://github.com/iovisor/bpftrace/issues/970)
- [bcc-tools: Go crash with
  uretprobe](https://github.com/iovisor/bcc/issues/1320)
- [`funclatency.py`](https://github.com/iovisor/bcc/blob/master/tools/funclatency.py)
